// Generated by odin.dust (version 0.3.13) - do not edit
template <typename real_type, typename container>
__host__ __device__ real_type odin_sum1(const container x, size_t from, size_t to);
template <typename real_type, typename container>
__host__ __device__ real_type odin_sum2(const container x, int from_i, int to_i, int from_j, int to_j, int dim_x_1);
// [[dust::class(plague_stochastic)]]
// [[dust::time_type(discrete)]]
// [[dust::param(contact, has_default = FALSE, default_value = NULL, rank = 2, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(I_ini, has_default = FALSE, default_value = NULL, rank = 1, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(season, has_default = FALSE, default_value = NULL, rank = 1, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(a, has_default = TRUE, default_value = 0.004, rank = 0, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(beta_r, has_default = TRUE, default_value = 4.7, rank = 0, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(d_f, has_default = TRUE, default_value = 10L, rank = 0, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(d_r, has_default = TRUE, default_value = 0.2, rank = 0, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(dt, has_default = TRUE, default_value = list("/", 1L, 365L), rank = 0, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(g_r, has_default = TRUE, default_value = 0.02, rank = 0, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(K_f, has_default = TRUE, default_value = 6.57, rank = 0, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(K_r, has_default = TRUE, default_value = 2500L, rank = 0, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(m_r, has_default = TRUE, default_value = 20L, rank = 0, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(mu_f, has_default = TRUE, default_value = 0.008, rank = 0, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(mu_r, has_default = TRUE, default_value = 0.03, rank = 0, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(npop, has_default = TRUE, default_value = 25L, rank = 0, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(p, has_default = TRUE, default_value = 0.975, rank = 0, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(r_f, has_default = TRUE, default_value = 20L, rank = 0, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(r_r, has_default = TRUE, default_value = 5L, rank = 0, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(S_ini, has_default = TRUE, default_value = 1L, rank = 0, min = -Inf, max = Inf, integer = FALSE)]]
// [[dust::param(seasonal_amplitude, has_default = TRUE, default_value = 0.2, rank = 0, min = -Inf, max = Inf, integer = FALSE)]]
class plague_stochastic {
public:
  using real_type = double;
  using rng_state_type = dust::random::generator<real_type>;
  using data_type = dust::no_data;
  struct shared_type {
    real_type a;
    real_type beta_r;
    std::vector<real_type> contact;
    real_type d_f;
    real_type d_r;
    int dim_contact;
    int dim_contact_1;
    int dim_contact_2;
    int dim_F;
    int dim_F_flow;
    int dim_F_flow_1;
    int dim_F_flow_2;
    int dim_flea_growth_rate;
    int dim_I;
    int dim_I_flow;
    int dim_I_flow_1;
    int dim_I_flow_2;
    int dim_I_ini;
    int dim_lambda_r;
    int dim_N;
    int dim_n_births_R;
    int dim_n_births_S;
    int dim_n_deaths_I;
    int dim_n_deaths_R;
    int dim_n_deaths_S;
    int dim_n_emigrate_F;
    int dim_n_emigrate_I;
    int dim_n_emigrate_R;
    int dim_n_emigrate_S;
    int dim_n_flea_deaths;
    int dim_n_fleas_to_rats;
    int dim_n_immigrate_F;
    int dim_n_immigrate_I;
    int dim_n_immigrate_R;
    int dim_n_immigrate_S;
    int dim_n_IR;
    int dim_n_new_free_fleas;
    int dim_n_recovered;
    int dim_n_resistant_births;
    int dim_n_SI;
    int dim_n_susceptible_births;
    int dim_p_flea_to_rat;
    int dim_p_IR;
    int dim_p_rat_birth;
    int dim_p_SI;
    int dim_R;
    int dim_R_flow;
    int dim_R_flow_1;
    int dim_R_flow_2;
    int dim_rat_birth_rate;
    int dim_rat_birth_rate_clipped;
    int dim_S;
    int dim_S_flow;
    int dim_S_flow_1;
    int dim_S_flow_2;
    int dim_season;
    int dim_T_r;
    real_type dt;
    real_type g_r;
    std::vector<real_type> I_ini;
    std::vector<real_type> initial_F;
    std::vector<real_type> initial_I;
    std::vector<real_type> initial_N;
    std::vector<real_type> initial_R;
    std::vector<real_type> initial_S;
    real_type K_f;
    real_type K_r;
    real_type m_r;
    real_type mu_f;
    real_type mu_r;
    int npop;
    int offset_variable_F;
    int offset_variable_N;
    int offset_variable_R;
    real_type p;
    real_type p_flea_death;
    std::vector<real_type> p_IR;
    real_type p_migrate_f;
    real_type p_migrate_r;
    real_type p_rat_death;
    real_type r_f;
    real_type r_r;
    real_type S_ini;
    std::vector<real_type> season;
    real_type seasonal_amplitude;
  };
  struct internal_type {
    std::vector<real_type> F_flow;
    std::vector<real_type> flea_growth_rate;
    std::vector<real_type> I_flow;
    std::vector<real_type> lambda_r;
    std::vector<real_type> n_births_R;
    std::vector<real_type> n_births_S;
    std::vector<real_type> n_deaths_I;
    std::vector<real_type> n_deaths_R;
    std::vector<real_type> n_deaths_S;
    std::vector<real_type> n_emigrate_F;
    std::vector<real_type> n_emigrate_I;
    std::vector<real_type> n_emigrate_R;
    std::vector<real_type> n_emigrate_S;
    std::vector<real_type> n_flea_deaths;
    std::vector<real_type> n_fleas_to_rats;
    std::vector<real_type> n_immigrate_F;
    std::vector<real_type> n_immigrate_I;
    std::vector<real_type> n_immigrate_R;
    std::vector<real_type> n_immigrate_S;
    std::vector<real_type> n_IR;
    std::vector<real_type> n_new_free_fleas;
    std::vector<real_type> n_recovered;
    std::vector<real_type> n_resistant_births;
    std::vector<real_type> n_SI;
    std::vector<real_type> n_susceptible_births;
    std::vector<real_type> p_flea_to_rat;
    std::vector<real_type> p_rat_birth;
    std::vector<real_type> p_SI;
    std::vector<real_type> R_flow;
    std::vector<real_type> rat_birth_rate;
    std::vector<real_type> rat_birth_rate_clipped;
    std::vector<real_type> S_flow;
    std::vector<real_type> T_r;
  };
  plague_stochastic(const dust::pars_type<plague_stochastic>& pars) :
    shared(pars.shared), internal(pars.internal) {
  }
  size_t size() const {
    return shared->dim_F + shared->dim_I + shared->dim_N + shared->dim_R + shared->dim_S;
  }
  std::vector<real_type> initial(size_t step, rng_state_type& rng_state) {
    std::vector<real_type> state(shared->dim_F + shared->dim_I + shared->dim_N + shared->dim_R + shared->dim_S);
    std::copy(shared->initial_S.begin(), shared->initial_S.end(), state.begin() + 0);
    std::copy(shared->initial_I.begin(), shared->initial_I.end(), state.begin() + shared->dim_S);
    std::copy(shared->initial_R.begin(), shared->initial_R.end(), state.begin() + shared->offset_variable_R);
    std::copy(shared->initial_N.begin(), shared->initial_N.end(), state.begin() + shared->offset_variable_N);
    std::copy(shared->initial_F.begin(), shared->initial_F.end(), state.begin() + shared->offset_variable_F);
    return state;
  }
  void update(size_t step, const real_type * state, rng_state_type& rng_state, real_type * state_next) {
    const real_type * S = state + 0;
    const real_type * I = state + shared->dim_S;
    const real_type * R = state + shared->offset_variable_R;
    const real_type * F = state + shared->offset_variable_F;
    const real_type * N = state + shared->offset_variable_N;
    real_type season_t = shared->season[step + 1 - 1];
    real_type K_f_seasonal = shared->K_f * dust::math::pow<real_type>((1 + shared->seasonal_amplitude), season_t);
    for (int i = 1; i <= shared->dim_flea_growth_rate; ++i) {
      internal.flea_growth_rate[i - 1] = shared->r_f * N[i - 1] * (1 - N[i - 1] / (real_type) K_f_seasonal) * shared->dt;
    }
    for (int i = 1; i <= shared->dim_n_deaths_I; ++i) {
      internal.n_deaths_I[i - 1] = dust::random::binomial<real_type>(rng_state, I[i - 1], shared->p_rat_death);
    }
    for (int i = 1; i <= shared->dim_n_deaths_R; ++i) {
      internal.n_deaths_R[i - 1] = dust::random::binomial<real_type>(rng_state, R[i - 1], shared->p_rat_death);
    }
    for (int i = 1; i <= shared->dim_n_deaths_S; ++i) {
      internal.n_deaths_S[i - 1] = dust::random::binomial<real_type>(rng_state, S[i - 1], shared->p_rat_death);
    }
    for (int i = 1; i <= shared->dim_n_emigrate_F; ++i) {
      internal.n_emigrate_F[i - 1] = dust::random::binomial<real_type>(rng_state, F[i - 1], shared->p_migrate_f);
    }
    for (int i = 1; i <= shared->dim_T_r; ++i) {
      internal.T_r[i - 1] = S[i - 1] + I[i - 1] + R[i - 1];
    }
    for (int i = 1; i <= shared->dim_F_flow_1; ++i) {
      int j = 1;
      internal.F_flow[i - 1 + shared->dim_F_flow_1 * (j - 1)] = dust::random::binomial<real_type>(rng_state, internal.n_emigrate_F[i - 1], shared->contact[shared->dim_contact_1 * 0 + i - 1]);
    }
    for (int i = 1; i <= shared->dim_F_flow_1; ++i) {
      for (int j = 2; j <= shared->npop; ++j) {
        internal.F_flow[i - 1 + shared->dim_F_flow_1 * (j - 1)] = dust::random::binomial<real_type>(rng_state, internal.n_emigrate_F[i - 1] - odin_sum2<real_type>(internal.F_flow.data(), i - 1, i, 0, j - 1, shared->dim_F_flow_1), shared->contact[shared->dim_contact_1 * (j - 1) + i - 1] / (real_type) odin_sum2<real_type>(shared->contact.data(), i - 1, i, j - 1, shared->npop, shared->dim_contact_1));
      }
    }
    for (int i = 1; i <= shared->dim_n_emigrate_R; ++i) {
      internal.n_emigrate_R[i - 1] = dust::random::binomial<real_type>(rng_state, R[i - 1] - internal.n_deaths_R[i - 1], shared->p_migrate_r);
    }
    for (int i = 1; i <= shared->dim_n_emigrate_S; ++i) {
      internal.n_emigrate_S[i - 1] = dust::random::binomial<real_type>(rng_state, S[i - 1] - internal.n_deaths_S[i - 1], shared->p_migrate_r);
    }
    for (int i = 1; i <= shared->dim_n_IR; ++i) {
      internal.n_IR[i - 1] = dust::random::binomial<real_type>(rng_state, I[i - 1] - internal.n_deaths_I[i - 1], shared->p_IR[i - 1]);
    }
    for (int i = 1; i <= shared->dim_p_flea_to_rat; ++i) {
      internal.p_flea_to_rat[i - 1] = 1 - dust::math::exp(- shared->a * internal.T_r[i - 1] * shared->dt);
    }
    for (int i = 1; i <= shared->dim_rat_birth_rate; ++i) {
      internal.rat_birth_rate[i - 1] = shared->r_r * (1 - internal.T_r[i - 1] / (real_type) shared->K_r);
    }
    for (int i = 1; i <= shared->dim_n_fleas_to_rats; ++i) {
      internal.n_fleas_to_rats[i - 1] = dust::random::binomial<real_type>(rng_state, F[i - 1], internal.p_flea_to_rat[i - 1]);
    }
    for (int i = 1; i <= shared->dim_n_immigrate_F; ++i) {
      internal.n_immigrate_F[i - 1] = odin_sum2<real_type>(internal.F_flow.data(), 0, shared->dim_F_flow_1, i - 1, i, shared->dim_F_flow_1);
    }
    for (int i = 1; i <= shared->dim_n_recovered; ++i) {
      internal.n_recovered[i - 1] = dust::random::binomial<real_type>(rng_state, internal.n_IR[i - 1], shared->g_r);
    }
    for (int i = 1; i <= shared->dim_R_flow_1; ++i) {
      int j = 1;
      internal.R_flow[i - 1 + shared->dim_R_flow_1 * (j - 1)] = dust::random::binomial<real_type>(rng_state, internal.n_emigrate_R[i - 1], shared->contact[shared->dim_contact_1 * 0 + i - 1]);
    }
    for (int i = 1; i <= shared->dim_R_flow_1; ++i) {
      for (int j = 2; j <= shared->npop; ++j) {
        internal.R_flow[i - 1 + shared->dim_R_flow_1 * (j - 1)] = dust::random::binomial<real_type>(rng_state, internal.n_emigrate_R[i - 1] - odin_sum2<real_type>(internal.R_flow.data(), i - 1, i, 0, j - 1, shared->dim_R_flow_1), shared->contact[shared->dim_contact_1 * (j - 1) + i - 1] / (real_type) odin_sum2<real_type>(shared->contact.data(), i - 1, i, j - 1, shared->npop, shared->dim_contact_1));
      }
    }
    for (int i = 1; i <= shared->dim_rat_birth_rate_clipped; ++i) {
      internal.rat_birth_rate_clipped[i - 1] = (internal.rat_birth_rate[i - 1] > 0 ? internal.rat_birth_rate[i - 1] : 0);
    }
    for (int i = 1; i <= shared->dim_S_flow_1; ++i) {
      int j = 1;
      internal.S_flow[i - 1 + shared->dim_S_flow_1 * (j - 1)] = dust::random::binomial<real_type>(rng_state, internal.n_emigrate_S[i - 1], shared->contact[shared->dim_contact_1 * 0 + i - 1]);
    }
    for (int i = 1; i <= shared->dim_S_flow_1; ++i) {
      for (int j = 2; j <= shared->npop; ++j) {
        internal.S_flow[i - 1 + shared->dim_S_flow_1 * (j - 1)] = dust::random::binomial<real_type>(rng_state, internal.n_emigrate_S[i - 1] - odin_sum2<real_type>(internal.S_flow.data(), i - 1, i, 0, j - 1, shared->dim_S_flow_1), shared->contact[shared->dim_contact_1 * (j - 1) + i - 1] / (real_type) odin_sum2<real_type>(shared->contact.data(), i - 1, i, j - 1, shared->npop, shared->dim_contact_1));
      }
    }
    for (int i = 1; i <= shared->dim_lambda_r; ++i) {
      internal.lambda_r[i - 1] = shared->beta_r * internal.n_fleas_to_rats[i - 1] / (real_type) internal.T_r[i - 1];
    }
    for (int i = 1; i <= shared->dim_n_emigrate_I; ++i) {
      internal.n_emigrate_I[i - 1] = dust::random::binomial<real_type>(rng_state, I[i - 1] - internal.n_deaths_I[i - 1] - (internal.n_IR[i - 1] - internal.n_recovered[i - 1]), shared->p_migrate_r);
    }
    for (int i = 1; i <= shared->dim_n_flea_deaths; ++i) {
      internal.n_flea_deaths[i - 1] = dust::random::binomial<real_type>(rng_state, F[i - 1] - internal.n_fleas_to_rats[i - 1], shared->p_flea_death);
    }
    for (int i = 1; i <= shared->dim_n_immigrate_R; ++i) {
      internal.n_immigrate_R[i - 1] = odin_sum2<real_type>(internal.R_flow.data(), 0, shared->dim_R_flow_1, i - 1, i, shared->dim_R_flow_1);
    }
    for (int i = 1; i <= shared->dim_n_immigrate_S; ++i) {
      internal.n_immigrate_S[i - 1] = odin_sum2<real_type>(internal.S_flow.data(), 0, shared->dim_S_flow_1, i - 1, i, shared->dim_S_flow_1);
    }
    for (int i = 1; i <= shared->dim_n_new_free_fleas; ++i) {
      internal.n_new_free_fleas[i - 1] = dust::math::floor(N[i - 1] * (internal.n_deaths_I[i - 1] + (internal.n_IR[i - 1] - internal.n_recovered[i - 1])));
    }
    for (int i = 1; i <= shared->dim_p_rat_birth; ++i) {
      internal.p_rat_birth[i - 1] = 1 - dust::math::exp(- internal.rat_birth_rate_clipped[i - 1] * shared->dt);
    }
    for (int i = 1; i <= shared->dim_N; ++i) {
      state_next[shared->offset_variable_N + i - 1] = N[i - 1] + internal.flea_growth_rate[i - 1] + internal.n_fleas_to_rats[i - 1] / (real_type) internal.T_r[i - 1];
    }
    for (int i = 1; i <= shared->dim_I_flow_1; ++i) {
      int j = 1;
      internal.I_flow[i - 1 + shared->dim_I_flow_1 * (j - 1)] = dust::random::binomial<real_type>(rng_state, internal.n_emigrate_I[i - 1], shared->contact[shared->dim_contact_1 * 0 + i - 1]);
    }
    for (int i = 1; i <= shared->dim_I_flow_1; ++i) {
      for (int j = 2; j <= shared->npop; ++j) {
        internal.I_flow[i - 1 + shared->dim_I_flow_1 * (j - 1)] = dust::random::binomial<real_type>(rng_state, internal.n_emigrate_I[i - 1] - odin_sum2<real_type>(internal.I_flow.data(), i - 1, i, 0, j - 1, shared->dim_I_flow_1), shared->contact[shared->dim_contact_1 * (j - 1) + i - 1] / (real_type) odin_sum2<real_type>(shared->contact.data(), i - 1, i, j - 1, shared->npop, shared->dim_contact_1));
      }
    }
    for (int i = 1; i <= shared->dim_n_births_R; ++i) {
      internal.n_births_R[i - 1] = dust::random::binomial<real_type>(rng_state, R[i - 1] - internal.n_deaths_R[i - 1], internal.p_rat_birth[i - 1] * static_cast<real_type>(0.75));
    }
    for (int i = 1; i <= shared->dim_n_births_S; ++i) {
      internal.n_births_S[i - 1] = dust::random::binomial<real_type>(rng_state, S[i - 1] - internal.n_deaths_S[i - 1], internal.p_rat_birth[i - 1]);
    }
    for (int i = 1; i <= shared->dim_p_SI; ++i) {
      internal.p_SI[i - 1] = 1 - dust::math::exp(- internal.lambda_r[i - 1]);
    }
    for (int i = 1; i <= shared->dim_F; ++i) {
      state_next[shared->offset_variable_F + i - 1] = F[i - 1] + internal.n_new_free_fleas[i - 1] - internal.n_flea_deaths[i - 1] - internal.n_fleas_to_rats[i - 1] - internal.n_emigrate_F[i - 1] + internal.n_immigrate_F[i - 1];
    }
    for (int i = 1; i <= shared->dim_n_immigrate_I; ++i) {
      internal.n_immigrate_I[i - 1] = odin_sum2<real_type>(internal.I_flow.data(), 0, shared->dim_I_flow_1, i - 1, i, shared->dim_I_flow_1);
    }
    for (int i = 1; i <= shared->dim_n_resistant_births; ++i) {
      internal.n_resistant_births[i - 1] = dust::random::binomial<real_type>(rng_state, internal.n_births_R[i - 1], shared->p);
    }
    for (int i = 1; i <= shared->dim_n_SI; ++i) {
      internal.n_SI[i - 1] = dust::random::binomial<real_type>(rng_state, S[i - 1] - internal.n_deaths_S[i - 1], internal.p_SI[i - 1]);
    }
    for (int i = 1; i <= shared->dim_n_susceptible_births; ++i) {
      internal.n_susceptible_births[i - 1] = internal.n_births_S[i - 1] + internal.n_births_R[i - 1] - internal.n_resistant_births[i - 1];
    }
    for (int i = 1; i <= shared->dim_I; ++i) {
      state_next[shared->dim_S + i - 1] = I[i - 1] + internal.n_SI[i - 1] - internal.n_IR[i - 1] - internal.n_deaths_I[i - 1] - internal.n_emigrate_I[i - 1] + internal.n_immigrate_I[i - 1];
    }
    for (int i = 1; i <= shared->dim_R; ++i) {
      state_next[shared->offset_variable_R + i - 1] = R[i - 1] + internal.n_recovered[i - 1] + internal.n_resistant_births[i - 1] - internal.n_deaths_R[i - 1] - internal.n_emigrate_R[i - 1] + internal.n_immigrate_R[i - 1];
    }
    for (int i = 1; i <= shared->dim_S; ++i) {
      state_next[0 + i - 1] = S[i - 1] - internal.n_SI[i - 1] + internal.n_susceptible_births[i - 1] - internal.n_deaths_S[i - 1] - internal.n_emigrate_S[i - 1] + internal.n_immigrate_S[i - 1];
    }
  }
private:
  std::shared_ptr<const shared_type> shared;
  internal_type internal;
};
template <typename real_type, typename container>
__host__ __device__ real_type odin_sum2(const container x, int from_i, int to_i, int from_j, int to_j, int dim_x_1) {
  real_type tot = 0.0;
  for (int j = from_j; j < to_j; ++j) {
    int jj = j * dim_x_1;
    for (int i = from_i; i < to_i; ++i) {
      tot += x[i + jj];
    }
  }
  return tot;
}
#include <array>
#include <cpp11/R.hpp>
#include <cpp11/sexp.hpp>
#include <cpp11/doubles.hpp>
#include <cpp11/integers.hpp>
#include <cpp11/list.hpp>
#include <cpp11/strings.hpp>
#include <memory>
#include <vector>

template <typename T>
inline bool is_na(T x);

template <>
inline bool is_na(int x) {
  return x == NA_INTEGER;
}

template <>
inline bool is_na(double x) {
  return ISNA(x);
}

inline size_t object_length(cpp11::sexp x) {
  return ::Rf_xlength(x);
}

template <typename T>
void user_check_value(T value, const char *name, T min, T max) {
  if (is_na(value)) {
    cpp11::stop("'%s' must not be NA", name);
  }
  if (!is_na(min) && value < min) {
    cpp11::stop("Expected '%s' to be at least %g", name, (double) min);
  }
  if (!is_na(max) && value > max) {
    cpp11::stop("Expected '%s' to be at most %g", name, (double) max);
  }
}

template <typename T>
void user_check_array_value(const std::vector<T>& value, const char *name,
                            T min, T max) {
  for (auto& x : value) {
    user_check_value(x, name, min, max);
  }
}

inline size_t user_get_array_rank(cpp11::sexp x) {
  if (!::Rf_isArray(x)) {
    return 1;
  } else {
    cpp11::integers dim = cpp11::as_cpp<cpp11::integers>(x.attr("dim"));
    return dim.size();
  }
}

template <size_t N>
void user_check_array_rank(cpp11::sexp x, const char *name) {
  size_t rank = user_get_array_rank(x);
  if (rank != N) {
    if (N == 1) {
      cpp11::stop("Expected a vector for '%s'", name);
    } else if (N == 2) {
      cpp11::stop("Expected a matrix for '%s'", name);
    } else {
      cpp11::stop("Expected an array of rank %d for '%s'",
                  static_cast<int>(N), name);
    }
  }
}

template <size_t N>
void user_check_array_dim(cpp11::sexp x, const char *name,
                          const std::array<int, N>& dim_expected) {
  cpp11::integers dim = cpp11::as_cpp<cpp11::integers>(x.attr("dim"));
  for (size_t i = 0; i < N; ++i) {
    if (dim[(int)i] != dim_expected[i]) {
      Rf_error("Incorrect size of dimension %d of '%s' (expected %d)",
               static_cast<int>(i + 1), name, dim_expected[i]);
    }
  }
}

template <>
inline void user_check_array_dim<1>(cpp11::sexp x, const char *name,
                                    const std::array<int, 1>& dim_expected) {
  if ((int)object_length(x) != dim_expected[0]) {
    cpp11::stop("Expected length %d value for '%s'", dim_expected[0], name);
  }
}

template <size_t N>
void user_set_array_dim(cpp11::sexp x, const char *name,
                        std::array<int, N>& dim) {
  cpp11::integers dim_given = cpp11::as_cpp<cpp11::integers>(x.attr("dim"));
  std::copy(dim_given.begin(), dim_given.end(), dim.begin());
}

template <>
inline void user_set_array_dim<1>(cpp11::sexp x, const char *name,
                                  std::array<int, 1>& dim) {
  dim[0] = object_length(x);
}

template <typename T>
T user_get_scalar(cpp11::list user, const char *name,
                  const T previous, T min, T max) {
  T ret = previous;
  cpp11::sexp x = user[name];
  if (x != R_NilValue) {
    if (object_length(x) != 1) {
      cpp11::stop("Expected a scalar numeric for '%s'", name);
    }
    // TODO: when we're getting out an integer this is a bit too relaxed
    if (TYPEOF(x) == REALSXP) {
      ret = cpp11::as_cpp<T>(x);
    } else if (TYPEOF(x) == INTSXP) {
      ret = cpp11::as_cpp<T>(x);
    } else {
      cpp11::stop("Expected a numeric value for %s", name);
    }
  }

  if (is_na(ret)) {
    cpp11::stop("Expected a value for '%s'", name);
  }
  user_check_value<T>(ret, name, min, max);
  return ret;
}

template <>
inline float user_get_scalar<float>(cpp11::list user, const char *name,
                                    const float previous, float min, float max) {
  double value = user_get_scalar<double>(user, name, previous, min, max);
  return static_cast<float>(value);
}

template <typename T>
std::vector<T> user_get_array_value(cpp11::sexp x, const char * name,
                                    T min, T max) {
  std::vector<T> ret = cpp11::as_cpp<std::vector<T>>(x);
  user_check_array_value<T>(ret, name, min, max);
  return ret;
}

template <typename T, size_t N>
std::vector<T> user_get_array_fixed(cpp11::list user, const char *name,
                                    const std::vector<T> previous,
                                    const std::array<int, N>& dim,
                                    T min, T max) {
  cpp11::sexp x = user[name];
  if (x == R_NilValue) {
    if (previous.size() == 0) {
      cpp11::stop("Expected a value for '%s'", name);
    }
    return previous;
  }

  user_check_array_rank<N>(x, name);
  user_check_array_dim<N>(x, name, dim);

  return user_get_array_value<T>(x, name, min, max);
}

template <typename T, size_t N>
std::vector<T> user_get_array_variable(cpp11::list user, const char *name,
                                       std::vector<T> previous,
                                       std::array<int, N>& dim,
                                       T min, T max) {
  cpp11::sexp x = user[name];
  if (x == R_NilValue) {
    if (previous.size() == 0) {
      cpp11::stop("Expected a value for '%s'", name);
    }
    return previous;
  }

  user_check_array_rank<N>(x, name);
  user_set_array_dim<N>(x, name, dim);

  return user_get_array_value<T>(x, name, min, max);
}

template <>
inline std::vector<float> user_get_array_value(cpp11::sexp x, const char * name,
                                               float min, float max) {
  // NOTE: possible under/overflow here for min/max because we've
  // downcast this.
  std::vector<double> value = user_get_array_value<double>(x, name, min, max);
  std::vector<float> ret(value.size());
  std::copy(value.begin(), value.end(), ret.begin());
  return ret;
}

// This is sum with inclusive "from", exclusive "to", following the
// same function in odin
template <typename real_type, typename container>
__host__ __device__
real_type odin_sum1(const container x, size_t from, size_t to) {
  real_type tot = 0.0;
  for (size_t i = from; i < to; ++i) {
    tot += x[i];
  }
  return tot;
}

inline cpp11::writable::integers integer_sequence(size_t from, size_t len) {
  cpp11::writable::integers ret(len);
  int* data = INTEGER(ret);
  for (size_t i = 0, j = from; i < len; ++i, ++j) {
    data[i] = j;
  }
  return ret;
}
namespace dust {
template<>
dust::pars_type<plague_stochastic> dust_pars<plague_stochastic>(cpp11::list user) {
  using real_type = typename plague_stochastic::real_type;
  auto shared = std::make_shared<plague_stochastic::shared_type>();
  plague_stochastic::internal_type internal;
  shared->a = static_cast<real_type>(0.0040000000000000001);
  shared->beta_r = static_cast<real_type>(4.7000000000000002);
  shared->d_f = 10;
  shared->d_r = static_cast<real_type>(0.20000000000000001);
  shared->dt = 1 / (real_type) 365;
  shared->g_r = static_cast<real_type>(0.02);
  shared->K_f = static_cast<real_type>(6.5700000000000003);
  shared->K_r = 2500;
  shared->m_r = 20;
  shared->mu_f = static_cast<real_type>(0.0080000000000000002);
  shared->mu_r = static_cast<real_type>(0.029999999999999999);
  shared->npop = 25;
  shared->p = static_cast<real_type>(0.97499999999999998);
  shared->r_f = 20;
  shared->r_r = 5;
  shared->S_ini = 1;
  shared->seasonal_amplitude = static_cast<real_type>(0.20000000000000001);
  shared->a = user_get_scalar<real_type>(user, "a", shared->a, NA_REAL, NA_REAL);
  shared->beta_r = user_get_scalar<real_type>(user, "beta_r", shared->beta_r, NA_REAL, NA_REAL);
  shared->d_f = user_get_scalar<real_type>(user, "d_f", shared->d_f, NA_REAL, NA_REAL);
  shared->d_r = user_get_scalar<real_type>(user, "d_r", shared->d_r, NA_REAL, NA_REAL);
  shared->dt = user_get_scalar<real_type>(user, "dt", shared->dt, NA_REAL, NA_REAL);
  shared->g_r = user_get_scalar<real_type>(user, "g_r", shared->g_r, NA_REAL, NA_REAL);
  shared->K_f = user_get_scalar<real_type>(user, "K_f", shared->K_f, NA_REAL, NA_REAL);
  shared->K_r = user_get_scalar<real_type>(user, "K_r", shared->K_r, NA_REAL, NA_REAL);
  shared->m_r = user_get_scalar<real_type>(user, "m_r", shared->m_r, NA_REAL, NA_REAL);
  shared->mu_f = user_get_scalar<real_type>(user, "mu_f", shared->mu_f, NA_REAL, NA_REAL);
  shared->mu_r = user_get_scalar<real_type>(user, "mu_r", shared->mu_r, NA_REAL, NA_REAL);
  shared->npop = user_get_scalar<int>(user, "npop", shared->npop, NA_INTEGER, NA_INTEGER);
  shared->p = user_get_scalar<real_type>(user, "p", shared->p, NA_REAL, NA_REAL);
  shared->r_f = user_get_scalar<real_type>(user, "r_f", shared->r_f, NA_REAL, NA_REAL);
  shared->r_r = user_get_scalar<real_type>(user, "r_r", shared->r_r, NA_REAL, NA_REAL);
  shared->S_ini = user_get_scalar<real_type>(user, "S_ini", shared->S_ini, NA_REAL, NA_REAL);
  std::array <int, 1> dim_season;
  shared->season = user_get_array_variable<real_type, 1>(user, "season", shared->season, dim_season, NA_REAL, NA_REAL);
  shared->dim_season = shared->season.size();
  shared->seasonal_amplitude = user_get_scalar<real_type>(user, "seasonal_amplitude", shared->seasonal_amplitude, NA_REAL, NA_REAL);
  shared->dim_contact_1 = shared->npop;
  shared->dim_contact_2 = shared->npop;
  shared->dim_F = shared->npop;
  shared->dim_F_flow_1 = shared->npop;
  shared->dim_F_flow_2 = shared->npop;
  shared->dim_flea_growth_rate = shared->npop;
  shared->dim_I = shared->npop;
  shared->dim_I_flow_1 = shared->npop;
  shared->dim_I_flow_2 = shared->npop;
  shared->dim_I_ini = shared->npop;
  shared->dim_lambda_r = shared->npop;
  shared->dim_N = shared->npop;
  shared->dim_n_births_R = shared->npop;
  shared->dim_n_births_S = shared->npop;
  shared->dim_n_deaths_I = shared->npop;
  shared->dim_n_deaths_R = shared->npop;
  shared->dim_n_deaths_S = shared->npop;
  shared->dim_n_emigrate_F = shared->npop;
  shared->dim_n_emigrate_I = shared->npop;
  shared->dim_n_emigrate_R = shared->npop;
  shared->dim_n_emigrate_S = shared->npop;
  shared->dim_n_flea_deaths = shared->npop;
  shared->dim_n_fleas_to_rats = shared->npop;
  shared->dim_n_immigrate_F = shared->npop;
  shared->dim_n_immigrate_I = shared->npop;
  shared->dim_n_immigrate_R = shared->npop;
  shared->dim_n_immigrate_S = shared->npop;
  shared->dim_n_IR = shared->npop;
  shared->dim_n_new_free_fleas = shared->npop;
  shared->dim_n_recovered = shared->npop;
  shared->dim_n_resistant_births = shared->npop;
  shared->dim_n_SI = shared->npop;
  shared->dim_n_susceptible_births = shared->npop;
  shared->dim_p_flea_to_rat = shared->npop;
  shared->dim_p_IR = shared->npop;
  shared->dim_p_rat_birth = shared->npop;
  shared->dim_p_SI = shared->npop;
  shared->dim_R = shared->npop;
  shared->dim_R_flow_1 = shared->npop;
  shared->dim_R_flow_2 = shared->npop;
  shared->dim_rat_birth_rate = shared->npop;
  shared->dim_rat_birth_rate_clipped = shared->npop;
  shared->dim_S = shared->npop;
  shared->dim_S_flow_1 = shared->npop;
  shared->dim_S_flow_2 = shared->npop;
  shared->dim_T_r = shared->npop;
  shared->p_flea_death = 1 - dust::math::exp(- shared->d_f * shared->dt);
  shared->p_migrate_f = 1 - dust::math::exp(- shared->mu_f * shared->dt);
  shared->p_migrate_r = 1 - dust::math::exp(- shared->mu_r * shared->dt);
  shared->p_rat_death = 1 - dust::math::exp(- shared->d_r * shared->dt);
  internal.flea_growth_rate = std::vector<real_type>(shared->dim_flea_growth_rate);
  shared->initial_F = std::vector<real_type>(shared->dim_F);
  shared->initial_I = std::vector<real_type>(shared->dim_I);
  shared->initial_N = std::vector<real_type>(shared->dim_N);
  shared->initial_R = std::vector<real_type>(shared->dim_R);
  shared->initial_S = std::vector<real_type>(shared->dim_S);
  internal.lambda_r = std::vector<real_type>(shared->dim_lambda_r);
  internal.n_births_R = std::vector<real_type>(shared->dim_n_births_R);
  internal.n_births_S = std::vector<real_type>(shared->dim_n_births_S);
  internal.n_deaths_I = std::vector<real_type>(shared->dim_n_deaths_I);
  internal.n_deaths_R = std::vector<real_type>(shared->dim_n_deaths_R);
  internal.n_deaths_S = std::vector<real_type>(shared->dim_n_deaths_S);
  internal.n_emigrate_F = std::vector<real_type>(shared->dim_n_emigrate_F);
  internal.n_emigrate_I = std::vector<real_type>(shared->dim_n_emigrate_I);
  internal.n_emigrate_R = std::vector<real_type>(shared->dim_n_emigrate_R);
  internal.n_emigrate_S = std::vector<real_type>(shared->dim_n_emigrate_S);
  internal.n_flea_deaths = std::vector<real_type>(shared->dim_n_flea_deaths);
  internal.n_fleas_to_rats = std::vector<real_type>(shared->dim_n_fleas_to_rats);
  internal.n_immigrate_F = std::vector<real_type>(shared->dim_n_immigrate_F);
  internal.n_immigrate_I = std::vector<real_type>(shared->dim_n_immigrate_I);
  internal.n_immigrate_R = std::vector<real_type>(shared->dim_n_immigrate_R);
  internal.n_immigrate_S = std::vector<real_type>(shared->dim_n_immigrate_S);
  internal.n_IR = std::vector<real_type>(shared->dim_n_IR);
  internal.n_new_free_fleas = std::vector<real_type>(shared->dim_n_new_free_fleas);
  internal.n_recovered = std::vector<real_type>(shared->dim_n_recovered);
  internal.n_resistant_births = std::vector<real_type>(shared->dim_n_resistant_births);
  internal.n_SI = std::vector<real_type>(shared->dim_n_SI);
  internal.n_susceptible_births = std::vector<real_type>(shared->dim_n_susceptible_births);
  internal.p_flea_to_rat = std::vector<real_type>(shared->dim_p_flea_to_rat);
  shared->p_IR = std::vector<real_type>(shared->dim_p_IR);
  internal.p_rat_birth = std::vector<real_type>(shared->dim_p_rat_birth);
  internal.p_SI = std::vector<real_type>(shared->dim_p_SI);
  internal.rat_birth_rate = std::vector<real_type>(shared->dim_rat_birth_rate);
  internal.rat_birth_rate_clipped = std::vector<real_type>(shared->dim_rat_birth_rate_clipped);
  internal.T_r = std::vector<real_type>(shared->dim_T_r);
  shared->dim_contact = shared->dim_contact_1 * shared->dim_contact_2;
  shared->dim_F_flow = shared->dim_F_flow_1 * shared->dim_F_flow_2;
  shared->dim_I_flow = shared->dim_I_flow_1 * shared->dim_I_flow_2;
  shared->dim_R_flow = shared->dim_R_flow_1 * shared->dim_R_flow_2;
  shared->dim_S_flow = shared->dim_S_flow_1 * shared->dim_S_flow_2;
  shared->I_ini = user_get_array_fixed<real_type, 1>(user, "I_ini", shared->I_ini, {shared->dim_I_ini}, NA_REAL, NA_REAL);
  for (int i = 1; i <= shared->dim_F; ++i) {
    shared->initial_F[i - 1] = 0;
  }
  for (int i = 1; i <= shared->dim_N; ++i) {
    shared->initial_N[i - 1] = shared->K_f;
  }
  for (int i = 1; i <= shared->dim_R; ++i) {
    shared->initial_R[i - 1] = shared->K_r * (1 - shared->S_ini);
  }
  for (int i = 1; i <= shared->dim_S; ++i) {
    shared->initial_S[i - 1] = shared->K_r * shared->S_ini;
  }
  shared->offset_variable_F = shared->dim_I + shared->dim_N + shared->dim_R + shared->dim_S;
  shared->offset_variable_N = shared->dim_I + shared->dim_R + shared->dim_S;
  shared->offset_variable_R = shared->dim_I + shared->dim_S;
  internal.F_flow = std::vector<real_type>(shared->dim_F_flow);
  internal.I_flow = std::vector<real_type>(shared->dim_I_flow);
  internal.R_flow = std::vector<real_type>(shared->dim_R_flow);
  internal.S_flow = std::vector<real_type>(shared->dim_S_flow);
  shared->contact = user_get_array_fixed<real_type, 2>(user, "contact", shared->contact, {shared->dim_contact_1, shared->dim_contact_2}, NA_REAL, NA_REAL);
  for (int i = 1; i <= shared->dim_I; ++i) {
    shared->initial_I[i - 1] = shared->I_ini[i - 1];
  }
  for (int i = 1; i <= shared->dim_p_IR; ++i) {
    shared->p_IR[i - 1] = 1 - dust::math::exp(- shared->m_r * shared->dt);
  }
  return dust::pars_type<plague_stochastic>(shared, internal);
}
template <>
cpp11::sexp dust_info<plague_stochastic>(const dust::pars_type<plague_stochastic>& pars) {
  const std::shared_ptr<const plague_stochastic::shared_type> shared = pars.shared;
  cpp11::writable::strings nms({"S", "I", "R", "N", "F"});
  cpp11::writable::list dim(5);
  dim[0] = cpp11::writable::integers({shared->dim_S});
  dim[1] = cpp11::writable::integers({shared->dim_I});
  dim[2] = cpp11::writable::integers({shared->dim_R});
  dim[3] = cpp11::writable::integers({shared->dim_N});
  dim[4] = cpp11::writable::integers({shared->dim_F});
  dim.names() = nms;
  cpp11::writable::list index(5);
  index[0] = integer_sequence(1, shared->dim_S);
  index[1] = integer_sequence(shared->dim_S + 1, shared->dim_I);
  index[2] = integer_sequence(shared->offset_variable_R + 1, shared->dim_R);
  index[3] = integer_sequence(shared->offset_variable_N + 1, shared->dim_N);
  index[4] = integer_sequence(shared->offset_variable_F + 1, shared->dim_F);
  index.names() = nms;
  size_t len = shared->offset_variable_F + shared->dim_F;
  using namespace cpp11::literals;
  return cpp11::writable::list({
           "dim"_nm = dim,
           "len"_nm = len,
           "index"_nm = index});
}
}
